<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GoldenGrape's Blog</title><link>https://goldengrape.github.io/</link><description>This is a blog site for GoldenGrape.</description><atom:link href="https://goldengrape.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2020 &lt;a href="mailto:https://twitter.com/goldengrape"&gt;Golden Grape&lt;/a&gt; </copyright><lastBuildDate>Fri, 31 Jul 2020 07:49:26 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>极简metalens(1)</title><link>https://goldengrape.github.io/posts/bulabula/crash_course_about_metalens_1/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;这篇极简科普是关于: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;metalens&lt;/li&gt;
&lt;li&gt;metasurface, 超表面, 超颖表面&lt;/li&gt;
&lt;li&gt;Pancharatnam Berry Phase&lt;/li&gt;
&lt;li&gt;几何相位, 贝里相位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是一个领域的东西. &lt;/p&gt;
&lt;p&gt;近期研读VR文献和专利, 反复发现Pancharatnam Berry Phase透镜这个东西, 如果入射光是圆偏振光, 可以产生相反的屈光度, 比如对于右旋圆偏振光(RCP)是+3D的透镜, 对于左旋圆偏振光(LCP)的就是-3D, 实在是非常魔法. 
&lt;img alt="" src="https://i.loli.net/2020/07/31/ml56zOgr1SfiKuJ.png"&gt;&lt;/p&gt;
&lt;p&gt;作为一个已经认真学习本领域技术1整天, 认识本领域专家的学生的师兄的哥们的, 不写剧情与人物的科幻小说(发明专利)作家. 我认为自己已经有足够的资格来撰写一篇极简科普. (没错我就是在黑各种极简).&lt;/p&gt;
&lt;p&gt;本极简科普是以临床眼科医生为假设读者撰写的, 就是那些听见“像差”就呵呵, 看见公式就晕过去的家伙们. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/bulabula/crash_course_about_metalens_1/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 4 分钟)&lt;/p&gt;&lt;/div&gt;</description><category>optics</category><guid>https://goldengrape.github.io/posts/bulabula/crash_course_about_metalens_1/</guid><pubDate>Fri, 31 Jul 2020 04:00:00 GMT</pubDate></item><item><title>坚决地无痛</title><link>https://goldengrape.github.io/posts/bulabula/Resolutely_painless/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;这是一个关于&lt;strong&gt;特定类型&lt;/strong&gt;运动损伤后的&lt;strong&gt;个人&lt;/strong&gt;经验:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;坚决&lt;/strong&gt;地无痛, 保持连续6-8小时&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这完全是个人经验, 我不是骨科或运动医学专业医生、这个经验不是任何专家推荐, 没有经过临床试验验证, 据我所知没有记录在教科书中, 也没有指南推荐. &lt;/p&gt;
&lt;p&gt;应用这个经验的风险, 需您自己承担. &lt;/p&gt;
&lt;p&gt;但据我所知, 这个经验并不违背常见的运动损伤处理原则. &lt;/p&gt;
&lt;p&gt;以下详细解释:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/bulabula/Resolutely_painless/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 1 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/Resolutely_painless/</guid><pubDate>Tue, 28 Jul 2020 04:00:00 GMT</pubDate></item><item><title>一种判定用笔正确与否的定量方法</title><link>https://goldengrape.github.io/posts/bulabula/A_quantitative_method_for%20determining_the_correct_use_of%20brush/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;据说是开尔文勋爵的语录: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;度量就是了解。如果你不能测量它，你就不能改善它。
To measure is to know. If you can not measure it, you can not improve it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;唐代张怀瓘说: “夫书，第一用笔，第二识势，第三裹束“&lt;/p&gt;
&lt;p&gt;我以为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用笔是&lt;strong&gt;科学&lt;/strong&gt;问题, 关注对不对: 如何行笔可以保持笔尖能够回复到初始状态; &lt;/li&gt;
&lt;li&gt;识势是&lt;strong&gt;技术&lt;/strong&gt;问题, 关注好不好: 按什么loss可以求最优解, 哪些常用解是独立的, 哪些是耦合的;&lt;/li&gt;
&lt;li&gt;裹束是&lt;strong&gt;艺术&lt;/strong&gt;问题, 关注美不美: 我不懂.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在练字只关心科学问题. 最近发现了定量度量用笔对不对的方法.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/bulabula/A_quantitative_method_for%20determining_the_correct_use_of%20brush/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 2 分钟)&lt;/p&gt;&lt;/div&gt;</description><category>书法</category><guid>https://goldengrape.github.io/posts/bulabula/A_quantitative_method_for%20determining_the_correct_use_of%20brush/</guid><pubDate>Sun, 26 Jul 2020 04:00:00 GMT</pubDate></item><item><title>Pancake光路</title><link>https://goldengrape.github.io/posts/python/pancake-optics/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Facebook发了一篇&lt;a href="https://research.fb.com/blog/2020/06/holographic-optics-for-thin-and-lightweight-virtual-reality/"&gt;非常华丽的paper&lt;/a&gt;, 里面用全息(Holographic, 原教旨意义的全息, 不是各种市场部吹嘘的引申假借)做了一个超薄的VR眼镜.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://research.fb.com/wp-content/uploads/2020/06/Holographic-optics_hero.png" alt="Holographic-optics"&gt;&lt;/p&gt;
&lt;p&gt;完全是一副未来已来的样子.&lt;/p&gt;
&lt;p&gt;不过我在看文献的时候, 却对里面回顾的另一个光路很感兴趣.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2020/07/01/jEaQNwtJFv2MspS.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;这个光路令光线往返了3次, 可以将光程缩短为原来的1/3, 当然也是有代价的, 代价是亮度降低到原来的25%, 不过看起来很有趣, 而且是一种通用的方案, 在其他的光路设计上也很有可能使用到. 同时, 对于其中元件的微小移动都可能造成3倍的光程变化, 对于调焦可能也很有用.&lt;/p&gt;
&lt;p&gt;于是我就决定用Jones矢量和Jones矩阵推导一下, 看看光路中到底发生了什么.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/python/pancake-optics/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 4 分钟)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>python</category><guid>https://goldengrape.github.io/posts/python/pancake-optics/</guid><pubDate>Wed, 01 Jul 2020 10:30:00 GMT</pubDate></item><item><title>笔顺</title><link>https://goldengrape.github.io/posts/bulabula/stroke_seq/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;我记得小学的时候, 曾经为笔顺的问题苦恼过, 这好像还考试过. 后来长大以后发现, 连会写字的人都不多了, 哪里还顾及什么写字的笔顺. 笔顺这种事情, 在现代社会就像是茴香豆的四种写法, 无用. 但偶尔考据一下也挺有趣的. &lt;/p&gt;
&lt;p&gt;在说笔顺的时候&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是针对手写的, 印刷的字没有笔顺的意义. &lt;/li&gt;
&lt;li&gt;是针对古代人手写的, 也就是用毛笔, 写繁体字. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;毛笔有毛笔的特点, 它是软的, 它是离散的笔毛构成的, 跟硬笔完全不同, (当然硬笔中钢笔和圆珠笔、铅笔也有不同). &lt;/p&gt;
&lt;p&gt;比如, 现代人用硬笔可以很方便用力画出一个圆圈或者方块, 但用毛笔就很麻烦. 毛笔如果用力画一个完整圆周, 笔毛会搅乱, 这样就没法再继续写下一笔了, 所以毛笔写字里要么分开画两个半周; 要么在画了180度以后要做个调锋的动作把笔毛顺回来, 再继续; 要么就要改变力度, 使用比较细的笔画画出一半圆. &lt;/p&gt;
&lt;p&gt;黄简老师讲过, 在手写的时候, 汉字的基本组成部分不是偏旁部首, 而是“笔势”. 基础的笔势有5个, 奋笔势、竖笔势、勾裹势、勾努势和衮笔势. 从这基础的五势出发, 还可以细分出更多的笔势, 名字都很帅气, 比如凤翅势、顾盼势、连波势...&lt;/p&gt;
&lt;p&gt;有一天我跟淳子小姐聊天时, 不慎把“势”写成了“式”, 她说这些名字颇有武侠之风. 一下子令人茅塞顿开, 我理解, 笔势, 就是常见的一些小的笔画组合, 这些笔画以这样的方式组合起来, 写得顺滑方便. 有点像武技中的小组合, 两个直拳以后近身一个勾拳再接一个横摆, 就很顺手, 也容易得手. 也和武技类似, 一个一个小组合按不同时间顺序连接起来就成了套路. 而一个一个笔势, 放在不同空间位置“裹束”起来就成了手写的字.&lt;/p&gt;
&lt;p&gt;手写是依照笔势来组织笔画, 因此笔顺是按照笔势来的, 不完全是按照偏旁部首来安排的. &lt;/p&gt;
&lt;p&gt;那么, 如何区分笔势, 或者如何知道一个字的笔顺呢? 我觉得可以去看那些写字好的人是怎么写的, 而且要找到能够看出他们笔画顺序的字. &lt;/p&gt;
&lt;p&gt;写字好的人自然是找书法家. 要看出字的笔画顺序, 则是应该找到行书. 篆隶、楷书(真书)太规整, 草书跟现代使用的文字差别又太大. 行书是最好, 笔画之间往往有牵丝或者飞渡, 能够看出笔尖行走的路径. 而且如果有墨迹本是最佳, 看得清楚. &lt;/p&gt;
&lt;p&gt;现在有很多书法辞典、网站、app, 可以一口气查到很多书法家所写的. 我喜欢&lt;a href="https://apps.apple.com/cn/app/%E4%B8%8D%E5%8E%8C%E4%B9%A6%E6%B3%95/id999813374"&gt;“不厌书法”&lt;/a&gt;这个app. 练字时还可以拍照对比. 随手查一下的话, 网站也不错. 比如&lt;a href="http://www.shufazidian.com/"&gt;书法字典&lt;/a&gt;. 注意, 书法家也有不同, 通常还是越有名、越古老的书法家越好. 王羲之是首选权威, 晋唐优先, 宋元次之, 明清就仅供参考了.&lt;/p&gt;
&lt;p&gt;好了, 来练习一下, 震惊语文老师的笔顺题.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集的笔顺是怎样的?&lt;/li&gt;
&lt;li&gt;盛的笔顺是怎样的?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/bulabula/stroke_seq/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 3 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/stroke_seq/</guid><pubDate>Mon, 15 Jun 2020 04:00:00 GMT</pubDate></item><item><title>OpenCV C++学习笔记(7): 命令行解析</title><link>https://goldengrape.github.io/posts/Cpp/openCV/opencv_7/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;OpenCV里有个CommandLineParser, 可以用来解析命令行, 方便不少.&lt;/p&gt;
&lt;p&gt;首先要定义一个keys:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"{help      |   | print this message}"&lt;/span&gt;
    &lt;span class="s"&gt;"{@input i  |   | input video file}"&lt;/span&gt;
    &lt;span class="s"&gt;"{@output o |   | output video file}"&lt;/span&gt;
    &lt;span class="s"&gt;"{low       |35 | low value}"&lt;/span&gt;
    &lt;span class="s"&gt;"{high      |100| high value}"&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;两根竖线里面是默认值&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;int main(int argc, const char * argv[])&lt;/code&gt;里面, 要声明一个&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="n"&gt;CommandLineParser&lt;/span&gt; &lt;span class="nf"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;接着就可以处理parser里的东西了, &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断一个参数有没有, 可以用&lt;code&gt;parser.has(参数名)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取得参数值, 可以用&lt;code&gt;parser.get&amp;lt;类型&amp;gt;(参数名或者序号)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如, 单独写一个函数来处理这些参数, 用传引用的方法来传递获取的参数值. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;get_CLI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CommandLineParser&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;output_filename&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;about&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"change video color and contrast"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//If requires help show&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"help"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printMessage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"@input"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"@output"&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
        &lt;span class="n"&gt;output_filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;output_filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;substr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;
        &lt;span class="s"&gt;"_changed.MP4"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/Cpp/openCV/opencv_7/</guid><pubDate>Wed, 10 Jun 2020 04:00:00 GMT</pubDate></item><item><title>练字录像</title><link>https://goldengrape.github.io/posts/bulabula/record_my_practice/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;学习了几天OpenCV以后, 我终于可以在练毛笔字时方便地录像了. 我这种Nerd, 练个毛笔字也要搞得像全栈开发的样子. &lt;/p&gt;
&lt;p&gt;&lt;img alt="兴_原本_small.2020-06-09 15_00_43" src="https://i.loli.net/2020/06/09/RmewGt4gHLrfFhP.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/bulabula/record_my_practice/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 1 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/record_my_practice/</guid><pubDate>Tue, 09 Jun 2020 05:00:00 GMT</pubDate></item><item><title>OpenCV C++学习笔记(6): 颜色识别定位</title><link>https://goldengrape.github.io/posts/Cpp/openCV/opencv_6/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;在 opencv-srf 网站上, 有一个&lt;a href="https://www.opencv-srf.com/2010/09/object-detection-using-color-seperation.html"&gt;颜色检测和物体跟踪&lt;/a&gt;的示例. 使用inRange来检测颜色, 并且Moments类来追踪这个颜色的物体. &lt;/p&gt;
&lt;p&gt;这个例子只能追踪&lt;strong&gt;一个&lt;/strong&gt;物体, 如果有多个同样颜色的物体, 用Moments只能找到这些物体最外面的框, 把这些物体当作一个, 找到他们的中心. 但这不是我想要的. 所以只好临摹了另外一个示例, 将两个凑在一起, 达成了目的.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/Cpp/openCV/opencv_6/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 1 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/Cpp/openCV/opencv_6/</guid><pubDate>Tue, 09 Jun 2020 04:00:00 GMT</pubDate></item><item><title>OpenCV C++学习笔记(5): 原位做4点投影变换</title><link>https://goldengrape.github.io/posts/Cpp/openCV/opencv_5/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://docs.opencv.org/master/de/dd4/samples_2cpp_2warpPerspective_demo_8cpp-example.html"&gt;OpenCV官方的warpPerspective示例&lt;/a&gt;用一个窗口进行选区, 用另一个窗口进行显示: &lt;/p&gt;
&lt;p&gt;&lt;img alt="trans" src="https://i.loli.net/2020/06/09/SK6PBipY4jnOWTR.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但我觉得这样有点麻烦, 不太适合移动端、小屏幕的操作. 于是做了一点改进, 使我可以在一个窗口内直接操作图像.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/Cpp/openCV/opencv_5/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 1 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/Cpp/openCV/opencv_5/</guid><pubDate>Tue, 09 Jun 2020 03:00:00 GMT</pubDate></item><item><title>OpenCV C++学习笔记(4): 4点投影变换</title><link>https://goldengrape.github.io/posts/Cpp/openCV/opencv_4/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;真正有趣的东西来了, 总算开始学到了用ffmpeg搞不定的事情. 就是用OpenCV写个类似office lens那样的东西, 把倾斜的平面给抻直. 或者准确的说, 是把源图上的4个点, 映射到目标图上的4个点. &lt;/p&gt;
&lt;p&gt;&lt;img alt="trans" src="https://i.loli.net/2020/06/09/SK6PBipY4jnOWTR.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://goldengrape.github.io/posts/Cpp/openCV/opencv_4/"&gt;阅读更多…&lt;/a&gt; (剩余阅读时间 1 分钟)&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/Cpp/openCV/opencv_4/</guid><pubDate>Tue, 09 Jun 2020 02:00:00 GMT</pubDate></item></channel></rss>